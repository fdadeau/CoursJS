<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    
    <link rel="stylesheet" href="../css/slides.css" type="text/css">
    <script src="../js/slides.js"></script>
    
    <script src="../js/codemirror.js"></script>
    <link rel="stylesheet" href="../css/codemirror.css">
    <script src="../js/javascript.js"></script>
    <script src="../js/css.js"></script>
    <script src="../js/xml.js"></script>
    <script src="../js/htmlmixed.js"></script>
    
    <script src="../js/playground.js"></script>
    <link rel="stylesheet" href="../css/playground.css">
    
    <title>Web avancé - Chapitre 3 - Javascript, côté serveur</title>
    
</head>

<!--
    Javascript côté serveur (1)
    - NodeJS
    - Express
    - Sockets.io
    - REST API
-->
    
<body>

<mask>
    <img src="../images/logo_ufc.png" class="top right padding" style="height: 7vh;">
<!--    <img src="../images/abeille.png" class="top right" style="height: 20vh;">
    <img src="../images/logo-femto.png" class="top left padding" style="height: 7vh;">-->
</mask>    
    

<slideshow>
        
    <title>Javascript, côté serveur</title>
    
    <slide>
        <title1>@ref{title}</title1>
    
        <title2>Cours &ldquo;Web avancé&rdquo; - Licence Info 3<sup>ème</sup> année</title2>

        <title3>Frédéric Dadeau - <a href="mailto:frederic.dadeau@univ-fcomte.fr">frederic.dadeau@univ-fcomte.fr</a></title3>
    </slide>
    
    <slide outline class="no-navigation section">
        <title>Plan du chapitre</title>
    </slide>
        
    <section>Node.js</section>
    
    <slide outline class="no-navigation section currentSection">
        <title>Plan du chapitre</title>
    </slide>

    <subsection>Historique</subsection>
    
    <slide>
        <title>JS ailleurs que dans le navigateur</title>
        
        <block title="Le projet CommonJS">
            <p>Projet fondé en Janvier 2009 par Kevin Dangoor, CommonJS (initialement nommé ServerJS) a 
                pour objectif de spécifier un écosystème pour Javascript <u>en dehors du navigateur</u>.
            </p>
        </block>
        
        <block title="Les limitations de Javascript dans le Browser">
            <ul>
                <li>Traitements uniquement côté client</li>
                <li>Pas de posssibilité d'accès au système de fichiers</li>
                <li>Pas de possibilité d'imports, ou de systèmes de modules</li>
            </ul>
        </block>
        
    </slide>
    
    <slide>
        <title>Node.js</title>
        
        <img src="images/nodejs.png" style="display: block; width: 30vh; height: auto; margin: 0 auto;">
        
        <block title="2010 : arrivée de Node.js">
            <p>Node.js a été écrit par Ryan Dahl en 2009 dans le cadre du projet CommonJS. Volonté initiale : 
                remplacer Apache que Dahl trouvait trop lent. Initialement Node.js s'appuyait :</p>
            <ul>
                <li>sur le moteur V8 de Chrome</li>
                <li>une boucle d'événements</li>
                <li>une API bas niveau pour les entrées/sorties</li>
            </ul>
            <p>L'architecture de Node.js est non-bloquante ce qui accélère considérablement les traitements. </p>
        </block>
        
        <block title="Et maintenant ?">
        <p>Node.js est désormais un environnement open-source côté serveur, gratuit, performant, qui s'exécute 
            sur de nombreuses plateformes et qui utilise Javascript. </p>
        </block>
    </slide>

    <subsection>Fonctionnalités</subsection>

    <slide>
        <title>Performance</title>
    
        <p>Sans Node.js<br><img src="images/node1.png" style="display: block; height: 25vh; width: auto; margin: 0 auto;"></p>
        
        <p>Avec Node.js<br>
            <img src="images/node2.png" style="display: block; height: 25vh; width: auto; margin: 0 auto;">
        </p>
        <p>
            Node.js s'exécute en mono-thread, non-bloquante, avec de la programmation asynchrone &rarr; très efficace.
        </p>
            
    </slide>
    
   <slide>
        <title>Node.js</title>
                
        <block title="Que peut faire Node.js ?">
            <p>Node.js peut effectuer les traitements suivants :</p>
            <ul>
                <li>générer des pages au contenu dynamique</li>
                <li>créer, ouvrir, lire, écrire, supprimer et fermer des fichiers sur le serveur</li>
                <li>collecter des données des formulaires</li>
                <li>s'interfacer avec une base de données côté serveur (pour ajouter, modifier, supprimer des enregistrements) </li>
            </ul>
        </block>    

        <block title="Comment fonctionne Node.js ?">
            <p>Node.js fonctionne avec un interpréteur installé sur un serveur (téléchargeable sur <url>https://nodejs.org</url>). </p>
            <p>Les fichiers .js exécutés (également appelé "initiés") avec cet environnement contiennent 
                des scripts qui seront exécutées à l'aide de la commande : <br>
                <code>$ node <i>mon_script.js</i></code></p>
            <p>Comme dans le navigateur, il est possible d'écrire du code en réponse à des événements du système 
                (consultation d'une page du serveur, réception d'une requête HTTP, etc.) </p>
        </block>    

    </slide>
    
    <subsection>Modules et NPM</subsection>

   <slide>
        <title>Node.js</title>
       
       <block title="Les modules">
           <p>Node.js s'appuie sur un ensemble de modules (des bibliothèques Javascript), qui peuvent être : </p>
            <ul>
                <li>soit intégrées à la distribution</li>
                <li>soit installés spécifiquement (avec <code>npm</code>)</li>
                <li>soit écrit par vos soins</li>
           </ul>
       </block>
       
       <block title="Importer un module dans le code">
        <p>L'importation d'un module se fait en utilisant la fonction <code>require(<i>nom_module</i>)</code>
            qui renvoie une instance du module (objet présentant des méthodes).</p>
        <p>Dans le cas où l'on référence un module que l'on a défini, il faut préciser le chemin vers le 
           fichier (sans son extension <code>.js</code>). </p>
       </block>
       
    </slide>
    
    
    
    <slide>
        <title>Modules Nodes.js</title>
       
       <block title="Quelques modules intéressants et utiles">
            <table>
            <tr>
                <td>Module</td><td>Description</td><td>natifs/<code>npm</code></td>    
            </tr>
            <tr>
                <td>http</td><td>Créer un serveur HTTP</td><td>natif</td>    
            </tr>
            <tr>
                <td>https</td><td>Créer un serveur HTTPS</td><td>natif</td>    
            </tr>
            <tr>
                <td>events</td><td>Manipuler des événements</td><td>natif</td>    
            </tr>
            <tr>
                <td>fs</td><td>Manipuler le système de fichiers</td><td>natif</td>    
            </tr>
            <tr>
                <td>path</td><td>Gérer des chemins dans le système de fichier</td><td>natif</td>    
            </tr>
            <tr>
                <td>url</td><td>Parser des URL</td><td>natif</td>    
            </tr>
            <tr>
                <td>assert</td><td>Réaliser des assertions</td><td>natif</td>    
            </tr>
            <tr>
                <td>express</td><td>Serveur HTTP amélioré</td><td><code>npm</code></td>    
            </tr>
            <tr>
                <td>socket.io</td><td>Manipulation des sockets</td><td><code>npm</code></td>    
            </tr>
            <tr>
                <td>mysql</td><td>Connexion avec une base de données MySQL</td><td><code>npm</code></td>    
            </tr>
            <tr>
                <td>mongodb</td><td>Connexion avec une base de données MongoDB</td><td><code>npm</code></td>    
            </tr>
            </table>
       </block>
       
        <p>Une liste complète des modules Node.js est disponible à l'adresse : 
            <url>https://www.w3schools.com/nodejs/ref_modules.asp</url></p>
        
    </slide>
    
    <slide>
        <title>Installer des modules avec npm</title>
        
        <block title="Node Package Manager">
            <p>Pour la gestion des modules installés, Node.js fournit un mécanisme qui permet 
            d'installer des paquetages (des modules) et leurs éventuelles dépendances. <br>
            Les paquetages existants sont centralisés sur un dépôt distant qui peut 
            être exploré et duquel il est possible de télécharger/d'installer des modules. </p>
        </block>
        
        <block title="Les commandes de <code>npm</code>">
            <table>
            <tr>
                <td>Commande</td><td>Description</td>
            </tr>
            <tr>
                <td><code>npm init</code></td>
                <td>Créé un fichier <code>package.json</code> contenant la description du projet<br> 
                (nom, point d'entrée, fichiers de tests associés, dépendances)</td>
            </tr>
            <tr>
                <td><code>npm search <i>quoi</i></code></td>
                <td>Recherche les modules référençant la recherche</td>
            </tr>
            <tr>
                <td><code>npm install <i>package</i></code></td>
                <td>Installe le module localement téléchargé avec ses dépendances dans un sous-répertoire <code>node_modules</code><br>
                    <code>--save</code> enregistre le module dans les dépendances du projet<br>
                    <code>-g</code> réalise une installation globale
            </tr>
            <tr>
                <td><code>npm uninstall <i>package</i></code></td>
                <td>Désinstalle le package</td>
            </tr>
            </table>        
        </block>
        <p>L'ensemble des modules disponibles sur le dépôt est donné à l'adresse : <url>https://www.npmjs.com/</url></p>
        
    </slide>
    
    
    <slide>
        <title>Installer des modules avec npm</title>
        
                
        <img src="images/npm-install.png" style="width: 30%; margin: 10px auto; float: right;">
        

    </slide>
    

    <subsubsection>HTTP - Serveur web</subsubsection>
    
    <slide>
        <title>Le module http</title>
        
        <block title="Qu'est-ce que c'est ?">
        <p>Le module natif <code>http</code> permet de créer un serveur HTTP, c'est-à-dire un service qui écoute 
            sur un port du serveur, reçoit des requêtes en HTTP et réalise un traitement en réponse. </p>
        </block>
        
        <block title="Principe de fonctionnement">
            <p>Le module <code>http</code> fournit une méthode <code>createServer</code> qui prend en paramètre 
            un écouteur de requête (<i>RequestListener</i>) qui est implémenté par une fonction à deux arguments: </p>
            <ul>
                <li><code>req</code> : objet représentant la requête HTTP formulée par le client (objet <code>IncomingMessage</code>) - 
                url demandée, query string, données transmises, etc.<br>
                    Voir <url>https://www.w3schools.com/nodejs/obj_http_incomingmessage.asp</url>.
                </li>
                <li><code>res</code> : objet représentant la réponse HTTP qui sera envoyée au client (objet <code>ServerResponse</code>) - 
                status (200 OK, 3XX redirection, 401 non authentifié, 403 accès refusé, 404 non trouvé, 5XX erreur serveur), 
                    entête HTTP, contenu de la réponse, etc. <br>
                    Voir <url>https://www.w3schools.com/nodejs/obj_http_serverresponse.asp</url>
                </li>
            </ul>
            <p>Le code d'un serveur http avec Node.js est très bas niveau : il faut prévoir une réponse pour chaque requête 
                qui va être adressée. </p>
        </block>

        
    </slide>

    <slide>
        <title>Le module http</title>
    
        <block title="Code d'un serveur très basique">
           <div class="playground nohtml nocss nooutput h30" data-href="./examples/jsNode1.html" data-opened="js"></div>
        </block>
        
        <block title="Exemples d'exécution">
        <table>
            <tr>
                <td>Requête HTTP (URL demandée)</td><td>Réponse du serveur</td>
            </tr>    
            <tr>
                <td><pre>http://<i>serveur</i>:8080</pre></td><td><pre>You requested: /</pre></td>
            </tr>    
            <tr>
                <td><pre>http://<i>serveur</i>:8080/index.html</pre></td><td><pre>You requested: /index.html</pre></td>
            </tr>    
            <tr>
                <td><pre>http://<i>serveur</i>:8080/images/JubeToutNuSurLaPlage.jpg</pre></td><td><pre>You requested: /images/JubeToutNuSurLaPlage.jpg</pre></td>
            </tr>    
        </table>
        </block>
        
    </slide>
    
    <slide>
        <title>Un langage de script côté serveur</title>
    
        <block title="Lien avec PHP">
            <p>Javascript s'exécutant côté serveur, il est donc possible d'écrire des scripts permettant de 
            <i>générer</i> des pages HTML qui seront envoyées aux clients. </p>
            <p>Comme PHP, vu en L2.</p>
        </block>
        
        <block title="Les templates">
            <p>Bien évidemment, personne ne génère les pages, <i>from scratch</i>, côté serveur. Il est possible
                d'utiliser un système de 
            templates pour fournir un rendu des différentes pages, qu'il ne reste plus qu'à alimenter
            avec un contenu particulier (spécifique à l'application que vous développez). </p>
            
            <p>On trouve un grand nombre de templates pour Node.js, qui s'installent comme des packages, 
                et permettent de décrire un contenu personnalisé (les informations affichées sont issues 
                du serveur ou d'une base de données) et variable (suivant l'état du serveur, le contenu affiché 
                peut être différent). </p>
            
            <p>Pour plus de détails, vous pouvez consulter cet article : 
                <url>https://colorlib.com/wp/top-templating-engines-for-javascript/</url></p>
        </block>
    
    </slide>
    
    
    <slide>
        <title>Le module fs</title>
        
        <block title="Le module <code>fs</code> (FileSystem)">
            <p>Comme son nom l'indique, ce module permet d'accéder au système de fichiers pour : </p>
            <ul>
                <li>lire, écrire dans des fichiers</li>
                <li>créer, déplacer, supprimer des fichiers, parcourir des répertoires, etc.</li>
            </ul>
            <p>Ce module est indispensable dans l'écriture d'un serveur web, pour "servir" les fichiers
            demandés par la requête HTTP (les lire sur le disque et aller envoyer au client).</p>
        </block>
        
        <block title="Lire un fichier">
        <p>L'accès et la lecture d'un fichier se fait via la fonction <code>readFile(path, options, callback)</code> où :</p>
        <ul>
            <li><code>path</code> : le chemin vers le fichier à lire</li>    
            <li><code>options</code> (facultatif) : objet représentant les options <code>{encoding: "...", flag: "r"}</code></li>    
            <li><code>callback</code> : fonction avec deux paramètres <code>function(err,data)</code> désignant l'éventuelle 
                erreur lors de la lecture, et le contenu du fichier. 
            </li>    
        </ul>
        <p>Le callback est déclenché lors de la fin de l'exécution de la méthode &rarr; pas de blocage lors de l'accès aux fichiers. </p>
        </block>
    </slide>
    
    <slide>
        <title>Modules http et fs</title>
        
        <block title="Un serveur déjà plus capable">
            <p>Par contre, si ma page a des paramètres ou une ancre, il faut être plus subtil... mais bon.</p>
            <div class="playground nohtml nocss nooutput h50" data-href="./examples/jsNode2.html" data-opened="js"></div>
        </block>
        
        <p>La référence du module File System : <url>https://www.w3schools.com/nodejs/ref_fs.asp</url>.</p>
        
    </slide>
    
    <subsubsection>URL - Traitement des URL</subsubsection>

    <slide>
        <title>Module URL</title>
    
        <block title="Manipuler des URL">
            <P>Node.js fournit nativement un module <code>url</code> qui permet de manipuler une URL pour 
            les parser et en extraire les éléments intéressants. </P>
            <p>Les fonctionnalités sont proches de celles proposées par l'objet <code>Window.location</code>
            du navigateur. </p>
        </block>
        
        <block title="Quelques fonctions utiles de ce module">
            <p>Après instanciation avec <code>var url = require('url')</code> et parsing d'une URL avec 
            <code>url.parse(<i>monURL</i>)</code>, les propriétés suivantes sont disponibles : </p>
            <table>
                <tr><td>Propriété</td><td>Description</td></tr>
                <tr><td><code>href</code></td><td>L'URL complète du document</td></tr>
                <tr><td><code>protocol</code></td><td>Le protocole de l'URL</td></tr>
                <tr><td><code>host</code></td><td>Le nom d'hôte et le numéro de port</td></tr>
                <tr><td><code>hostname</code></td><td>Le nom d'hôte</td></tr>
                <tr><td><code>port</code></td><td>Le numéro de port</td></tr>
                <tr><td><code>origin</code></td><td>Le protocole, le nom d'hôte et le numéro de port</td></tr>
                <tr><td><code>pathname</code></td><td>Le chemin d'accès dans l'URL</td></tr>
                <tr><td><code>search</code></td><td>La partie requète (après le <code>?</code>)</td></tr>
                <tr><td><code>hash</code></td><td>L'ancre ciblée (après le <code>#</code>)</td></tr>
            </table>
        </block>
        
    </slide>
    
    <slide>
        <title>Modules http, fs et url</title>
        
        <block title="Un serveur finalement apte">
           <div class="playground nohtml nocss nooutput h50" data-href="./examples/jsNode3.html" data-opened="js"></div>
        </block>
                
    </slide>
    
    <slide>
        <title>Ecrire ses modules</title>
    
        <block title="Exporter les fonctions de l'API du module">
            <p>L'écriture d'un module Node.js n'est pas différente de l'écriture 
            d'un code Javascript classique, à ceci près que les variables déclarées 
                dans le module ont une portée qui est locale au module. </p>
            
            <p>De ce fait, les fonctions que l'on souhaite rendre visibles de l'extérieur doivent 
                exportées en les être rattachées à l'objet <code>exports</code> spécifique aux modules node.</p>
        </block>
        
        <block title="Exemple de module <code>database.js</code>">
            <p>Ce module sera importé avec <code>var maBase = require("./database");</code></p>
           <div class="playground nohtml nocss nooutput h30" data-href="./examples/jsNode4.html" data-opened="js"></div>
        </block>
        
    </slide>
    
    
    <section>L'architecture REST</section>

    <slide outline class="no-navigation section currentSection">
        <title>Plan du chapitre</title>
    </slide>
    
    <subsection>Principes</subsection>
    
    <slide>
        <title>L'architecture REST</title>
        
        <block title="Qu'est-ce que c'est ?">
            <P>REST (REpresentational State Transfer) est une architecture côté serveur qui s'appuie
            sur le protocole HTTP, qui a été proposée par Roy Fielding dans sa thèse de doctorat. </P>
            <p>Ce style d'architecture se définit suivant 6 concepts-clés : </p>
            <ul>
            <li>Pas d'états côté serveur : seule la requête du client permet au serveur de calculer 
                le résultat, aucune information d'une requête antérieure n'est nécessaire. </li>
            <li>Mise en cache : possibilité de mettre en cache les réponses pour éviter de surcharger le 
                réseau avec des échanges superflus.</li>
            <li>Client-Serveur : indépendance de ces entités ; l'interface utilisateur est séparée de celle du stockage des données
                et peut évoluer séparément. </li>
            <li>System de couches : le client communique avec un serveur qui peut lui-même s'appuyer sur un autre serveur. </li>
            <li>Code à la demande (optionnel) : le serveur peut potentiellement transférer du code exécutable au client 
                pour étendre ses fonctionnalités. </li>
            <li>Interface uniforme : (1) identification des ressources dans les requêtes, (2) manipulation des ressources
                en utilisant leur représentation, (3) messages se décrivant eux-mêmes (méta-données), (4) utilisation des 
                hypermédia comme moteur de l'application </li>
            </ul>
        </block>
        
    </slide>
    
    
    <slide>
        <title>Les API RESTful</title>
        
        <block title="REST pour les services web">
            <p>Les architectures REST peuvent être mise en place pour développer des services web. Ceux-ci 
            seront basées sur HTTP et présenteront les éléments suivants :</p>
            <ul>
                <li>une URL de base (ex. <code>http://api.monsite.com/</code>)</li>
                <li>un identificateur de ressource formulé comme un URI (ex. <code>/ressource/item42</code>)</li>
                <li>l'utilisation de méthodes standard HTTP : GET, POST, PUT, DELETE</li>
            </ul>
        </block>
        
        <block title="Mapping CRUD/HTTP">
            <row>
            <div>
                <p>URI d'une collection (ex. <code>/ressource</code>)</p>
                <table>
                    <tr><td>Méthode HTTP</td><td>CRUD action</td></tr>
                    <tr><td>POST</td><td>Create - créé une nouvelle entrée</td></tr>
                    <tr><td>GET</td><td>Read - liste les URI des entrées</td></tr>
                    <tr><td>PUT</td><td>Update - remplace la collection</td></tr>
                    <tr><td>DELETE</td><td>Delete - supprime la collection</td></tr>
                </table>
            </div>
            <div>
                <p>URI d'un élément (ex. <code>/ressource/item42</code>)</p>
                <table>
                <tr><td>Méthode HTTP</td><td>CRUD action</td></tr>
                    <tr><td>POST</td><td>Create - pas vraiment de sens</td></tr>
                    <tr><td>GET</td><td>Read - récupère les informations de l'entrée</td></tr>
                    <tr><td>PUT</td><td>Update - met à jour l'entrée</td></tr>
                    <tr><td>DELETE</td><td>Delete - supprimer l'entrée</td></tr>
                </table>
            </div>
        </block>
    </slide>
    
    
    <subsection>Construire une API RESTful avec Express</subsection>
    

    <slide>
        <title>Le module Express</title>
        
        <block title="Qu'est-ce que c'est ?">
        <p>Express est un module Node.js permettant de développer des middlewares avec une infrastructure 
            "minimaliste et flexible".  </p>
        <p>Au delà des fonctionnalités classiques vues précédemment, Express permet de définir simplement 
            le routage au sein d'une application web, facilitant grandement l'implémentation de serveurs
            RESTful. </p>
        </block>
        
        <block title="Utiliser Express">
        <p>Express s'installe avec le gestionnaire de paquets <code>npm</code> <br>
            <code>npm install express [--save]</code></p>
        
        <p>Le module s'importe classiquement dans le script avec<br>
            <code>var express = require('express');</code> <br>
        </p>
            <p>Il ne reste plus qu'à instancier l'application Express<br>
                <code>var app = express();</code><br>
            et à la paramétrer avant de l'exécuter pour lancer le serveur web. </p>
        </block>
        
        <p>La documentation complète d'Express se trouve à l'adresse <url>http://expressjs.com/fr</url></p>
        
    </slide>
    
    <slide>
        <title>Le module Express</title>
            
        <block title="Routage avec Express">
            <p><code>app.<i>method</i>(<i>chemin</i>, function(req, res) { ... })</code> permet de définir les règles de routage : </p>
            <ul>
                <li><code><i>method</i></code> peut être <code>get</code>, <code>post</code>, <code>put</code>, 
                    <code>delete</code> (et d'autres encore...)</li>
                <li><code><i>chemin</i></code> est le chemin que l'on souhaite matcher dans l'application (ex. <code>'/api/liste'</code>)</li>
                <li><code><i>req</i></code> représente la requête HTTP formulée par le client (propriétés : 
                    <code>query</code>, <code>body</code> - voir <url>http://expressjs.com/fr/4x/api.html#req</url>)</li>
                <li><code><i>res</i></code> représente la réponse HTTP à forger pour le client (méthodes utiles : 
                    <code>.status(<i>code</i>)</code>, <code>.type(<i>type_reponse</i>)</code>, 
                    <code>.end(<i>texte</i>)</code>, <code>.send(<i>données</i>)</code>, 
                    ou <code>json(<i>données_JSON</i>)</code> - voir <url>http://expressjs.com/fr/4x/api.html#res</url>)</li>
            </ul>
            <div class="playground nohtml nocss nooutput h30" data-href="./examples/jsNode6.html" data-opened="js"></div>
        </block>

    </slide>
        
    <slide>
        <title>Le module Express</title>
        
        <block title="Récupérer des paramètres dans le routage">
        <p>Il est possible de matcher un paramètre dans une route, avec la syntaxe <code>:id</code> dans l'URI
            de la ressource. </p>
        <p>L'ensemble des paramètres accessibles depuis l'objet <code>req</code> de type <code>Request</code> 
            de l'API d'Express qui contient un objet <code>params</code> 
            (voir <url>http://expressjs.com/fr/4x/api.html#req</url>)</p>
        </block>
    
        <block title="Récupérer le corps d'une requête">
        <p>Le corps de la requête sera porté par l'attribut <code>req.body</code>.
            Celui-ci ne sera instancié que si des parseurs spécifiques (package <code>bodyParser</code>) ont été 
            définis au préalable, comme par exemple :</p>
        <ul>
            <li><code>app.use(bodyParser.json())</code> pour parser des données au format JSON, ou </li>
            <li><code>app.use(bodyParser.urlencoded({ extended: true }))</code> pour parser des données <code>application/x-www-form-urlencoded</code></li>
        </ul>
        </block>    
        
    </slide>
        
    <slide>
        <title>Le module Express</title>    
        
        <block title="Une API RESTful avec Express">
            <div class="playground nohtml nocss nooutput h50" data-href="./examples/jsNode5.html" data-opened="js"></div>        
        </block>
        
    </slide>    
        
        
    <slide>
        <title>Le module Express</title>
        
        <block title="Servir automatiquement des fichiers statiques">
        <p>Pour éviter de devoir vérifier une à une les demandes qui seraient liées à des fichiers statiques
            (les fichiers de l'application), Express donne la possibilité de paramétrer un répertoire racine 
            vers lequel seront routées les demandes. Par exemple, </p>

            <p><code>app.use(express.static('public'));</code> </p>
            
            <p>donne ainsi accès aux fichiers HTML, CSS et Javascript situés dans le répertoire <code>public</code>
            de l'arborescence du serveur. 
        </p>
        </block>

        <p>Voir <url>http://expressjs.com/fr/starter/static-files.html</url> pour plus de détails.</p>
        
    </slide>    
        
        
    <section>Les sockets</section>    
        
    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="Les sockets qu'est-ce que c'est ?">
            <p>Une socket est un moyen de communication bi-directionnel entre un client et un serveur. </p>
            <p>Depuis HTML5, un protocole a été défini : <strong>websocket</strong> qui permet au navigateur
            de communiquer avec un serveur qui implante ce protocole (handshake avec échange de clés). </p>
        </block>
        
        <img src="images/sockets.png" class="figure" style="height: 20vh; width: auto;">
        
    </slide>    
        
              
    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="Côté serveur : <code>sockets.io</code>">
            <p>Le package <code>sockets.io</code> implante côté serveur avec Node.js tout le nécessaire 
                pour l'utilisation de websockets. <br>
                <code>npm install socket.io [--save]</code></p>
        </block>
        
        <block title="Fonctionnement des sockets">
            <p>Comme vu en cours de Systèmes et Réseaux : </p>
            <ul>
                <li>le serveur écoute sur un port particulier et attend les connexions des clients</li>
                <li>un client se connecte au serveur</li>
                <li>les clients et le serveur échangent des messages : le serveur peut envoyer des messages à un client particulier ou à tous les clients connectés (broadcast). </li>
                <li>le client peut se déconnecter du serveur. </li>
            </ul>
        </block>
        
    </slide>    
        
               
    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="En Javascript, tout ceci passe par des événements">
            <p>La mise en place est donc très simple... (plus qu'en C).</p>
            
        </block>
            
        <block title="Attente de connexion côté serveur">
            <div class="playground nohtml nocss nooutput h40" data-href="./examples/jsNode7.html" data-opened="js"></div>        
        </block>
        
    </slide>    
            
                
    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="Et côté client, ça se passe comment ?">
            <p>La première chose à faire est de charger la bibliothèque gérant les sockets (celle fournie 
                avec <code>sockets.io</code> est faites pour cela).</p>
            <p><code>&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;</code></p>
            <p>Puis, il suffit d'ouvrir la connexion avec <code>io.connect(<i>url</i>)</code>. </p>
        </block>
               
        <block title="Ouverture de connexion côté client">
            <div class="playground nohtml nocss nooutput h20" data-href="./examples/jsNode7client.html" data-opened="js"></div>        
        </block>
        
    </slide>    
                
    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="Autres événements intéressants">
            <p>Le serveur peut envoyer des messages à un client, ou en recevoir, et gérer les déconnexions des clients, 
                en associant des événements à la socket avec laquelle le client se connecte. </p>
            <div class="playground nohtml nocss nooutput h40" data-href="./examples/jsNode8.html" data-opened="js"></div>        
        </block>
        
    </slide>    

    <slide>
        <title>Utilisation de sockets</title>
        
        <block title="Côté client">
            <p>Le client a la possibilité d'envoyer et de recevoir des messages.</p>
            <div class="playground nohtml nocss nooutput h40" data-href="./examples/jsNode8client.html" data-opened="js"></div>        
        </block>
    
        <p>Pour plus de détails : <url>https://socket.io</url></p>
        
    </slide>    
        
        
        
    
    <slide>
        <title>Bilan</title>
        
        <p>Côté serveur, nous avons vu le strict minimum concernant Node.js, mais vous avez normalement les
        clés pour partir à l'aventure sur ce sujet si le coeur vous en dit. </p>
        
        <p>Vous pouvez notamment manipuler des sockets avec les clients (package <code>sockets.io</code>), 
            vous connecter à une base de données relationnelle MySQL (package <code>mysql</code>) ou Postgres 
            (package <code>pg</code>), ou à une base de donnée NoSQL comme MongoDB (package 
            <code>moongoose</code>).
        </p>
        
        <p>Pour un bilan complet sur Javascript, si vous souhaitez vous rendre compte de la richesse de 
        l'écosystème Javascript actuel, je ne peux que vous conseiller la lecture de ces notes de blog : </p>
        
        <ul style="width: 90%; margin: -10px auto 0 auto; line-height: 1.2;">
            <li><url>https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f</url></li>
            <li><url>https://medium.com/front-end-hacking/how-it-feels-to-learn-javascript-in-2017-a934b801fbe</url></li>
            <li><url>https://codeburst.io/how-it-feels-to-learn-javascript-in-2018-6b2cf7abb6aa</url></li>
            <li><url>https://javascript-obfuscator.org/blog/how-it-feels-like-to-learn-javascript-in-2020/</url></li>
        </ul>
        
        <p>...accompagnée d'une bonne aspirine.</p>
        
    </slide>
    
    <!---
    <slide>
        <title>Et le test dans tout ça ?</title>    
        
        <p>Côté client, nous avons vu Selenium qui permet de tester des aspects fonctionnels. Selenium 
        est implanté dans différents langages (y compris Javascript : <url>https://blog.testproject.io/2018/03/08/selenium-javascript-best-practices</url>).</p>

        <block title="Test côté serveur">
            <p>De nombreux framework de test existent, basés sur Node.js. En effet, celui-ci fournit un environnement 
            d'exécution JS indépendant du navigateur, mais pouvant simuler celui-ci (notamment les manipulations du DOM). </p>
            <ul>
                <li>Jest : <url>https://jestjs.io</url></li>
                <li>UnitJS : <url>https://unitjs.com/</url></li>
                <li>Mocha : <url>https://mochajs.org/</url></li>
                <li>Jasmine : <url>https://jasmine.github.io</url></li>
                <li>Cypress : <url>https://www.cypress.io/</url></li>
                <li>Cucumber : <url>https://cucumber.io/</url></li>
                <li>Nightwatch : <url>http://nightwatchjs.org/</url></li>
                <li>PhantomJS : <url>http://phantomjs.org/</url></li>
            </ul>
            <p>Chacun de ces frameworks a une utilisation bien spécifique, mais vous retrouverez ce que vous avez vu 
                dans le module Outils pour la Programmation (assertions, intégration continue, etc.). </p>
            
        <p>Pour plus de détails : <url>https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3</url></p>
        
        </block>

    </slide>

-->
        

        
    <slide>
        <title>Quelques ressources</title>    
        
        <block title="Ressources Node.js">
        <ul>
            <li>Documentation officielle : <url>https://nodejs.org/en/docs/</url></li>
            <li>Ouvrage gratuit en ligne : <url>https://oncletom.io/node.js/</url></li>
            <li>Tutoriel w3schools : <url>https://www.w3schools.com/nodejs/</url></li>
            <li>Ensemble de tutoriels : <url>https://www.grafikart.fr/tutoriels/nodejs</url></li>
        </ul>
        </block>

        <block title="Packages Node.js">
        <ul>
            <li>Liste des packages existants : <url>https://www.npmjs.com/</url></li>
            <li>Documentation Express : <url>http://expressjs.com/fr/</url></li>
            <li>Nodejs + Express (Mozilla) : <url>https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs</url></li>
            <li>Les sockets avec sockets.io : <url>https://socket.io/docs/#</url></li>
        </ul>
        </block>      
        
        <p>Et pour avoir une vision globale sur Javascript aujourd'hui : <url>https://stateofjs.com/</url></p>
                
    </slide>    
        
    <slide class="nonavigation">
        
        <title2>Prochaine étape...</title2>
        
        <title1>La mise en pratique !</title1>
        
    </slide>
        
        
</slideshow>    
        
</body>
    
</html>